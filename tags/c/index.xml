<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>C on CYH Blog</title><link>https://jack2012aa.github.io/CYH-blog/tags/c/</link><description>Recent content in C on CYH Blog</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Mon, 07 Jul 2025 17:13:38 +0800</lastBuildDate><atom:link href="https://jack2012aa.github.io/CYH-blog/tags/c/index.xml" rel="self" type="application/rss+xml"/><item><title>[CS 5204 Operating Systems Project 1] Multi-thread Web Server</title><link>https://jack2012aa.github.io/CYH-blog/posts/cs-5204/cs-5204-p1/</link><pubDate>Mon, 07 Jul 2025 17:13:38 +0800</pubDate><guid>https://jack2012aa.github.io/CYH-blog/posts/cs-5204/cs-5204-p1/</guid><description>&lt;h3 id="linkhttpsgithubcomjack2012aacs5204-spring25-p1">&lt;a href="https://github.com/jack2012aa/CS5204-Spring25-P1">Link&lt;/a>&lt;/h3>
&lt;h2 id="description">Description&lt;/h2>
&lt;p>I implemented a simple Web server in this project. It listens to specific port for http requests. To increase throughput, it has to be multi-thread and obey Smallest File Scheduling as well as having some mechanism to avoid starvation.&lt;/p>
&lt;h2 id="implementation">Implementation&lt;/h2>
&lt;h3 id="multithreading">Multithreading&lt;/h3>
&lt;p>Using &lt;code>pthread&lt;/code> is the simplest way to accomplish multithreading in C. The logic of Web server is extremely match with the producer-consumer architecture. Hence, I used the main thread as the producer, which polls request from the port file descriptor. The new task is appended to a queue and the thread goes back to polling. Idle consumers try to get a task from the queue.&lt;/p></description></item></channel></rss>