<!doctype html><html class="not-ready lg:text-base" style=--bg:#faf8f1 lang=en-us dir=ltr><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>[CS 5204 Operating Systems Project 1] Multi-thread Web Server - CYH Blog</title>
<meta name=theme-color><meta name=description content="Link
Description
I implemented a simple Web server in this project. It listens to specific port for http requests. To increase throughput, it has to be multi-thread and obey Smallest File Scheduling as well as having some mechanism to avoid starvation.
Implementation
Multithreading
Using pthread is the simplest way to accomplish multithreading in C. The logic of Web server is extremely match with the producer-consumer architecture. Hence, I used the main thread as the producer, which polls request from the port file descriptor. The new task is appended to a queue and the thread goes back to polling. Idle consumers try to get a task from the queue."><meta name=author content="Chang-Yu Huang"><link rel="preload stylesheet" as=style href=https://jack2012aa.github.io/CYH-blog/main.min.css><link rel=preload as=image href=https://jack2012aa.github.io/CYH-blog/theme.png><link rel=preload as=image href=img/oct.JPG><link rel=preload as=image href=https://jack2012aa.github.io/CYH-blog/github.svg><script defer src=https://jack2012aa.github.io/CYH-blog/highlight.min.js onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://jack2012aa.github.io/CYH-blog/img/cloud.JPG><link rel=apple-touch-icon href=https://jack2012aa.github.io/CYH-blog/apple-touch-icon.png><meta name=generator content="Hugo 0.139.3"><meta itemprop=name content="[CS 5204 Operating Systems Project 1] Multi-thread Web Server"><meta itemprop=description content="Link Description I implemented a simple Web server in this project. It listens to specific port for http requests. To increase throughput, it has to be multi-thread and obey Smallest File Scheduling as well as having some mechanism to avoid starvation.
Implementation Multithreading Using pthread is the simplest way to accomplish multithreading in C. The logic of Web server is extremely match with the producer-consumer architecture. Hence, I used the main thread as the producer, which polls request from the port file descriptor. The new task is appended to a queue and the thread goes back to polling. Idle consumers try to get a task from the queue."><meta itemprop=datePublished content="2025-07-07T17:13:38+08:00"><meta itemprop=dateModified content="2025-07-07T17:13:38+08:00"><meta itemprop=wordCount content="245"><meta itemprop=keywords content="C,Operating Systems"><meta property="og:url" content="https://jack2012aa.github.io/CYH-blog/posts/cs-5204/cs-5204-p1/"><meta property="og:site_name" content="CYH Blog"><meta property="og:title" content="[CS 5204 Operating Systems Project 1] Multi-thread Web Server"><meta property="og:description" content="Link Description I implemented a simple Web server in this project. It listens to specific port for http requests. To increase throughput, it has to be multi-thread and obey Smallest File Scheduling as well as having some mechanism to avoid starvation.
Implementation Multithreading Using pthread is the simplest way to accomplish multithreading in C. The logic of Web server is extremely match with the producer-consumer architecture. Hence, I used the main thread as the producer, which polls request from the port file descriptor. The new task is appended to a queue and the thread goes back to polling. Idle consumers try to get a task from the queue."><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-07-07T17:13:38+08:00"><meta property="article:modified_time" content="2025-07-07T17:13:38+08:00"><meta property="article:tag" content="C"><meta property="article:tag" content="Operating Systems"><meta name=twitter:card content="summary"><meta name=twitter:title content="[CS 5204 Operating Systems Project 1] Multi-thread Web Server"><meta name=twitter:description content="Link Description I implemented a simple Web server in this project. It listens to specific port for http requests. To increase throughput, it has to be multi-thread and obey Smallest File Scheduling as well as having some mechanism to avoid starvation.
Implementation Multithreading Using pthread is the simplest way to accomplish multithreading in C. The logic of Web server is extremely match with the producer-consumer architecture. Hence, I used the main thread as the producer, which polls request from the port file descriptor. The new task is appended to a queue and the thread goes back to polling. Idle consumers try to get a task from the queue."><link rel=canonical href=https://jack2012aa.github.io/CYH-blog/posts/cs-5204/cs-5204-p1/></head><body class="text-black duration-200 ease-out dark:text-white"><header class="mx-auto flex h-[4.5rem] max-w-[--w] px-8 lg:justify-center"><div class="relative z-50 ltr:mr-auto rtl:ml-auto flex items-center"><a class="-translate-y-[1px] text-2xl font-medium" href=https://jack2012aa.github.io/CYH-blog/>CYH Blog</a><div class="btn-dark text-[0] ltr:ml-4 rtl:mr-4 h-6 w-6 shrink-0 cursor-pointer [background:url(./theme.png)_left_center/_auto_theme('spacing.6')_no-repeat] [transition:_background-position_0.4s_steps(5)] dark:[background-position:right]" role=button aria-label=Dark></div></div><div class="btn-menu relative z-50 ltr:-mr-8 rtl:-ml-8 flex h-[4.5rem] w-[5rem] shrink-0 cursor-pointer flex-col items-center justify-center gap-2.5 lg:hidden" role=button aria-label=Menu></div><script>const htmlClass=document.documentElement.classList;setTimeout(()=>{htmlClass.remove("not-ready")},10);const btnMenu=document.querySelector(".btn-menu");btnMenu.addEventListener("click",()=>{htmlClass.toggle("open")});const metaTheme=document.querySelector('meta[name="theme-color"]'),lightBg="#faf8f1".replace(/"/g,""),setDark=e=>{metaTheme.setAttribute("content",e?"#000":lightBg),htmlClass[e?"add":"remove"]("dark"),localStorage.setItem("dark",e)},darkScheme=window.matchMedia("(prefers-color-scheme: dark)");if(htmlClass.contains("dark"))setDark(!0);else{const e=localStorage.getItem("dark");setDark(e?e==="true":darkScheme.matches)}darkScheme.addEventListener("change",e=>{setDark(e.matches)});const btnDark=document.querySelector(".btn-dark");btnDark.addEventListener("click",()=>{setDark(localStorage.getItem("dark")!=="true")})</script><div class="nav-wrapper fixed inset-x-0 top-full z-40 flex h-full select-none flex-col justify-center pb-16 duration-200 dark:bg-black lg:static lg:h-auto lg:flex-row lg:!bg-transparent lg:pb-0 lg:transition-none"><nav class="lg:ml-12 lg:flex lg:flex-row lg:items-center lg:space-x-10 rtl:space-x-reverse"><a class="block text-center text-xl leading-[5rem] lg:text-base lg:font-normal" href=/CYH-blog/about/>About</a>
<a class="block text-center text-xl leading-[5rem] lg:text-base lg:font-normal" href=/CYH-blog/categories/courseworks/>Courseworks</a></nav><nav class="mt-12 flex justify-center space-x-10 rtl:space-x-reverse dark:invert ltr:lg:ml-14 rtl:lg:mr-14 lg:mt-0 lg:items-center"><a class="h-7 w-7 text-[0] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6" style=--url:url(./github.svg) href=https://github.com/jack2012aa target=_blank rel=me>github</a></nav></div></header><main class="prose prose-neutral relative mx-auto min-h-[calc(100vh-9rem)] max-w-[--w] px-8 pb-16 pt-14 dark:prose-invert"><article><header class=mb-14><h1 class="!my-0 pb-2.5">[CS 5204 Operating Systems Project 1] Multi-thread Web Server</h1><div class="text-xs antialiased opacity-60"><time>Jul 7, 2025</time></div></header><section><h3 id=linkhttpsgithubcomjack2012aacs5204-spring25-p1><a href=https://github.com/jack2012aa/CS5204-Spring25-P1>Link</a></h3><h2 id=description>Description</h2><p>I implemented a simple Web server in this project. It listens to specific port for http requests. To increase throughput, it has to be multi-thread and obey Smallest File Scheduling as well as having some mechanism to avoid starvation.</p><h2 id=implementation>Implementation</h2><h3 id=multithreading>Multithreading</h3><p>Using <code>pthread</code> is the simplest way to accomplish multithreading in C. The logic of Web server is extremely match with the producer-consumer architecture. Hence, I used the main thread as the producer, which polls request from the port file descriptor. The new task is appended to a queue and the thread goes back to polling. Idle consumers try to get a task from the queue.</p><h3 id=queue-and-smallest-file-scheduling>Queue and Smallest File Scheduling</h3><p>To avoid race condition and waste of CPU, the queue is protected by a lock and a condition variable. Both enqueue and dequeue may be blocked because the queue is full / empty.
Since the Smallest File First scheduling is based on the size of required html, the queue must be a priority queue. The main thread parses the size information and then pack them into a <code>work</code> structure. The priority queue uses these information to compare the work.</p><h3 id=starvation>Starvation</h3><p>I solve the starvation problem by defining a weight for each work. The initial weight is the file size. Everytime a smallest task is picked, the scheduler decrease the largest work&rsquo;s weight by multipling a number less than 1.</p><h2 id=usage>Usage</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>prompt&gt; make
</span></span><span style=display:flex><span>prompt&gt; ./wserver <span style=color:#f92672>[</span>-d basedir<span style=color:#f92672>]</span> <span style=color:#f92672>[</span>-p port<span style=color:#f92672>]</span> <span style=color:#f92672>[</span>-t threads<span style=color:#f92672>]</span> <span style=color:#f92672>[</span>-b buffers<span style=color:#f92672>]</span>
</span></span></code></pre></div></section><footer class="mt-12 flex flex-wrap"><a class="mb-1.5 ltr:mr-1.5 rtl:ml-1.5 rounded-lg bg-black/[3%] px-5 py-1 no-underline hover:bg-black/[6%] dark:bg-white/[8%] dark:hover:bg-white/[12%]" href=https://jack2012aa.github.io/CYH-blog/tags/c>C</a>
<a class="mb-1.5 ltr:mr-1.5 rtl:ml-1.5 rounded-lg bg-black/[3%] px-5 py-1 no-underline hover:bg-black/[6%] dark:bg-white/[8%] dark:hover:bg-white/[12%]" href=https://jack2012aa.github.io/CYH-blog/tags/operating-systems>Operating Systems</a></footer><nav class="mt-24 flex overflow-hidden rounded-xl bg-black/[3%] text-lg !leading-[1.2] *:flex *:w-1/2 *:items-center *:p-5 *:font-medium *:no-underline dark:bg-white/[8%] [&>*:hover]:bg-black/[2%] dark:[&>*:hover]:bg-white/[3%]"><a class="ltr:ml-auto rtl:mr-auto justify-end pl-3" href=https://jack2012aa.github.io/CYH-blog/posts/cs-5040/cs-5040-p4/><span>[CS 5040 Data structures and algorithms Project 4] MemManager</span><span class="ltr:ml-1.5 rtl:mr-1.5">→</span></a></nav></article></main><footer class="mx-auto flex h-[4.5rem] max-w-[--w] items-center px-8 text-xs uppercase tracking-wider opacity-60"><div class=mr-auto>&copy; 2025
<a class=link href=https://jack2012aa.github.io/CYH-blog/>CYH Blog</a></div><a class="link mx-6" href=https://gohugo.io/ rel=noopener target=_blank>powered by hugo️️</a>️
<a class=link href=https://github.com/nanxiaobei/hugo-paper rel=noopener target=_blank>hugo-paper</a></footer></body></html>